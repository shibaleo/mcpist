// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Content) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Content) encodeFields(e *jx.Encoder) {
	{
		if s.ScriptId.Set {
			e.FieldStart("scriptId")
			s.ScriptId.Encode(e)
		}
	}
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfContent = [2]string{
	0: "scriptId",
	1: "files",
}

// Decode decodes Content from json.
func (s *Content) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Content to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scriptId":
			if err := func() error {
				s.ScriptId.Reset()
				if err := s.ScriptId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scriptId\"")
			}
		case "files":
			if err := func() error {
				s.Files = make([]ScriptFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScriptFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Content")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Content) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Content) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDeploymentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDeploymentRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("versionNumber")
		e.Int(s.VersionNumber)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ManifestFileName.Set {
			e.FieldStart("manifestFileName")
			s.ManifestFileName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDeploymentRequest = [3]string{
	0: "versionNumber",
	1: "description",
	2: "manifestFileName",
}

// Decode decodes CreateDeploymentRequest from json.
func (s *CreateDeploymentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDeploymentRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versionNumber":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.VersionNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionNumber\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "manifestFileName":
			if err := func() error {
				s.ManifestFileName.Reset()
				if err := s.ManifestFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manifestFileName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDeploymentRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDeploymentRequest) {
					name = jsonFieldsNameOfCreateDeploymentRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDeploymentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDeploymentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateProjectRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateProjectRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.ParentId.Set {
			e.FieldStart("parentId")
			s.ParentId.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateProjectRequest = [2]string{
	0: "title",
	1: "parentId",
}

// Decode decodes CreateProjectRequest from json.
func (s *CreateProjectRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateProjectRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "parentId":
			if err := func() error {
				s.ParentId.Reset()
				if err := s.ParentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateProjectRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateProjectRequest) {
					name = jsonFieldsNameOfCreateProjectRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateProjectRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateProjectRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateVersionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateVersionRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateVersionRequest = [1]string{
	0: "description",
}

// Decode decodes CreateVersionRequest from json.
func (s *CreateVersionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateVersionRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateVersionRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateVersionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateVersionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Deployment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Deployment) encodeFields(e *jx.Encoder) {
	{
		if s.DeploymentId.Set {
			e.FieldStart("deploymentId")
			s.DeploymentId.Encode(e)
		}
	}
	{
		if s.DeploymentConfig.Set {
			e.FieldStart("deploymentConfig")
			s.DeploymentConfig.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("updateTime")
			s.UpdateTime.Encode(e)
		}
	}
	{
		if s.EntryPoints != nil {
			e.FieldStart("entryPoints")
			e.ArrStart()
			for _, elem := range s.EntryPoints {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDeployment = [4]string{
	0: "deploymentId",
	1: "deploymentConfig",
	2: "updateTime",
	3: "entryPoints",
}

// Decode decodes Deployment from json.
func (s *Deployment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Deployment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deploymentId":
			if err := func() error {
				s.DeploymentId.Reset()
				if err := s.DeploymentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploymentId\"")
			}
		case "deploymentConfig":
			if err := func() error {
				s.DeploymentConfig.Reset()
				if err := s.DeploymentConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploymentConfig\"")
			}
		case "updateTime":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateTime\"")
			}
		case "entryPoints":
			if err := func() error {
				s.EntryPoints = make([]DeploymentEntryPointsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeploymentEntryPointsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.EntryPoints = append(s.EntryPoints, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entryPoints\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Deployment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Deployment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Deployment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeploymentConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeploymentConfig) encodeFields(e *jx.Encoder) {
	{
		if s.ScriptId.Set {
			e.FieldStart("scriptId")
			s.ScriptId.Encode(e)
		}
	}
	{
		if s.VersionNumber.Set {
			e.FieldStart("versionNumber")
			s.VersionNumber.Encode(e)
		}
	}
	{
		if s.ManifestFileName.Set {
			e.FieldStart("manifestFileName")
			s.ManifestFileName.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeploymentConfig = [4]string{
	0: "scriptId",
	1: "versionNumber",
	2: "manifestFileName",
	3: "description",
}

// Decode decodes DeploymentConfig from json.
func (s *DeploymentConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scriptId":
			if err := func() error {
				s.ScriptId.Reset()
				if err := s.ScriptId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scriptId\"")
			}
		case "versionNumber":
			if err := func() error {
				s.VersionNumber.Reset()
				if err := s.VersionNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionNumber\"")
			}
		case "manifestFileName":
			if err := func() error {
				s.ManifestFileName.Reset()
				if err := s.ManifestFileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"manifestFileName\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeploymentConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DeploymentEntryPointsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DeploymentEntryPointsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DeploymentEntryPointsItem from json.
func (s *DeploymentEntryPointsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentEntryPointsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentEntryPointsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeploymentEntryPointsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentEntryPointsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeploymentList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeploymentList) encodeFields(e *jx.Encoder) {
	{
		if s.Deployments != nil {
			e.FieldStart("deployments")
			e.ArrStart()
			for _, elem := range s.Deployments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeploymentList = [2]string{
	0: "deployments",
	1: "nextPageToken",
}

// Decode decodes DeploymentList from json.
func (s *DeploymentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeploymentList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deployments":
			if err := func() error {
				s.Deployments = make([]Deployment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Deployment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Deployments = append(s.Deployments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deployments\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeploymentList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeploymentList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeploymentList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecutionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecutionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("function")
		e.Str(s.Function)
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.DevMode.Set {
			e.FieldStart("devMode")
			s.DevMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecutionRequest = [3]string{
	0: "function",
	1: "parameters",
	2: "devMode",
}

// Decode decodes ExecutionRequest from json.
func (s *ExecutionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecutionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "function":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Function = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "devMode":
			if err := func() error {
				s.DevMode.Reset()
				if err := s.DevMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecutionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecutionRequest) {
					name = jsonFieldsNameOfExecutionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecutionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecutionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecutionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecutionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Done.Set {
			e.FieldStart("done")
			s.Done.Encode(e)
		}
	}
	{
		if s.Response.Set {
			e.FieldStart("response")
			s.Response.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfExecutionResponse = [3]string{
	0: "done",
	1: "response",
	2: "error",
}

// Decode decodes ExecutionResponse from json.
func (s *ExecutionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecutionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "done":
			if err := func() error {
				s.Done.Reset()
				if err := s.Done.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"done\"")
			}
		case "response":
			if err := func() error {
				s.Response.Reset()
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecutionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecutionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecutionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExecutionResponseError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExecutionResponseError) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExecutionResponseError from json.
func (s *ExecutionResponseError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecutionResponseError to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecutionResponseError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExecutionResponseError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecutionResponseError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ExecutionResponseResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ExecutionResponseResponse) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ExecutionResponseResponse from json.
func (s *ExecutionResponseResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecutionResponseResponse to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecutionResponseResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ExecutionResponseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecutionResponseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GoogleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GoogleUser) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PhotoUrl.Set {
			e.FieldStart("photoUrl")
			s.PhotoUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfGoogleUser = [4]string{
	0: "domain",
	1: "email",
	2: "name",
	3: "photoUrl",
}

// Decode decodes GoogleUser from json.
func (s *GoogleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GoogleUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "photoUrl":
			if err := func() error {
				s.PhotoUrl.Reset()
				if err := s.PhotoUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photoUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GoogleUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GoogleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GoogleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Metrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Metrics) encodeFields(e *jx.Encoder) {
	{
		if s.ActiveUsers != nil {
			e.FieldStart("activeUsers")
			e.ArrStart()
			for _, elem := range s.ActiveUsers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalExecutions != nil {
			e.FieldStart("totalExecutions")
			e.ArrStart()
			for _, elem := range s.TotalExecutions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FailedExecutions != nil {
			e.FieldStart("failedExecutions")
			e.ArrStart()
			for _, elem := range s.FailedExecutions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfMetrics = [3]string{
	0: "activeUsers",
	1: "totalExecutions",
	2: "failedExecutions",
}

// Decode decodes Metrics from json.
func (s *Metrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Metrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeUsers":
			if err := func() error {
				s.ActiveUsers = make([]MetricsValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MetricsValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveUsers = append(s.ActiveUsers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeUsers\"")
			}
		case "totalExecutions":
			if err := func() error {
				s.TotalExecutions = make([]MetricsValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MetricsValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TotalExecutions = append(s.TotalExecutions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalExecutions\"")
			}
		case "failedExecutions":
			if err := func() error {
				s.FailedExecutions = make([]MetricsValue, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MetricsValue
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FailedExecutions = append(s.FailedExecutions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failedExecutions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Metrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Metrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Metrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MetricsValue) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MetricsValue) encodeFields(e *jx.Encoder) {
	{
		if s.StartTime.Set {
			e.FieldStart("startTime")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.EndTime.Set {
			e.FieldStart("endTime")
			s.EndTime.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfMetricsValue = [3]string{
	0: "startTime",
	1: "endTime",
	2: "value",
}

// Decode decodes MetricsValue from json.
func (s *MetricsValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MetricsValue to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "endTime":
			if err := func() error {
				s.EndTime.Reset()
				if err := s.EndTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endTime\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MetricsValue")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MetricsValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MetricsValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeploymentConfig as json.
func (o OptDeploymentConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DeploymentConfig from json.
func (o *OptDeploymentConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeploymentConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeploymentConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeploymentConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExecutionResponseError as json.
func (o OptExecutionResponseError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExecutionResponseError from json.
func (o *OptExecutionResponseError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExecutionResponseError to nil")
	}
	o.Set = true
	o.Value = make(ExecutionResponseError)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExecutionResponseError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExecutionResponseError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ExecutionResponseResponse as json.
func (o OptExecutionResponseResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExecutionResponseResponse from json.
func (o *OptExecutionResponseResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExecutionResponseResponse to nil")
	}
	o.Set = true
	o.Value = make(ExecutionResponseResponse)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExecutionResponseResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExecutionResponseResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GoogleUser as json.
func (o OptGoogleUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GoogleUser from json.
func (o *OptGoogleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGoogleUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGoogleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGoogleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScriptFileFunctionSet as json.
func (o OptScriptFileFunctionSet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ScriptFileFunctionSet from json.
func (o *OptScriptFileFunctionSet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptScriptFileFunctionSet to nil")
	}
	o.Set = true
	o.Value = make(ScriptFileFunctionSet)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptScriptFileFunctionSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptScriptFileFunctionSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Process) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Process) encodeFields(e *jx.Encoder) {
	{
		if s.ProcessId.Set {
			e.FieldStart("processId")
			s.ProcessId.Encode(e)
		}
	}
	{
		if s.FunctionName.Set {
			e.FieldStart("functionName")
			s.FunctionName.Encode(e)
		}
	}
	{
		if s.ProcessType.Set {
			e.FieldStart("processType")
			s.ProcessType.Encode(e)
		}
	}
	{
		if s.ProcessStatus.Set {
			e.FieldStart("processStatus")
			s.ProcessStatus.Encode(e)
		}
	}
	{
		if s.StartTime.Set {
			e.FieldStart("startTime")
			s.StartTime.Encode(e)
		}
	}
	{
		if s.Duration.Set {
			e.FieldStart("duration")
			s.Duration.Encode(e)
		}
	}
	{
		if s.UserAccessLevel.Set {
			e.FieldStart("userAccessLevel")
			s.UserAccessLevel.Encode(e)
		}
	}
	{
		if s.ProjectName.Set {
			e.FieldStart("projectName")
			s.ProjectName.Encode(e)
		}
	}
	{
		if s.ExecutingUser.Set {
			e.FieldStart("executingUser")
			s.ExecutingUser.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcess = [9]string{
	0: "processId",
	1: "functionName",
	2: "processType",
	3: "processStatus",
	4: "startTime",
	5: "duration",
	6: "userAccessLevel",
	7: "projectName",
	8: "executingUser",
}

// Decode decodes Process from json.
func (s *Process) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Process to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processId":
			if err := func() error {
				s.ProcessId.Reset()
				if err := s.ProcessId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processId\"")
			}
		case "functionName":
			if err := func() error {
				s.FunctionName.Reset()
				if err := s.FunctionName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functionName\"")
			}
		case "processType":
			if err := func() error {
				s.ProcessType.Reset()
				if err := s.ProcessType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processType\"")
			}
		case "processStatus":
			if err := func() error {
				s.ProcessStatus.Reset()
				if err := s.ProcessStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processStatus\"")
			}
		case "startTime":
			if err := func() error {
				s.StartTime.Reset()
				if err := s.StartTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startTime\"")
			}
		case "duration":
			if err := func() error {
				s.Duration.Reset()
				if err := s.Duration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"duration\"")
			}
		case "userAccessLevel":
			if err := func() error {
				s.UserAccessLevel.Reset()
				if err := s.UserAccessLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAccessLevel\"")
			}
		case "projectName":
			if err := func() error {
				s.ProjectName.Reset()
				if err := s.ProjectName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectName\"")
			}
		case "executingUser":
			if err := func() error {
				s.ExecutingUser.Reset()
				if err := s.ExecutingUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executingUser\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Process")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Process) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Process) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProcessList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProcessList) encodeFields(e *jx.Encoder) {
	{
		if s.Processes != nil {
			e.FieldStart("processes")
			e.ArrStart()
			for _, elem := range s.Processes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfProcessList = [2]string{
	0: "processes",
	1: "nextPageToken",
}

// Decode decodes ProcessList from json.
func (s *ProcessList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "processes":
			if err := func() error {
				s.Processes = make([]Process, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Process
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Processes = append(s.Processes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"processes\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProcessList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProcessList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Project) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Project) encodeFields(e *jx.Encoder) {
	{
		if s.ScriptId.Set {
			e.FieldStart("scriptId")
			s.ScriptId.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.ParentId.Set {
			e.FieldStart("parentId")
			s.ParentId.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("createTime")
			s.CreateTime.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("updateTime")
			s.UpdateTime.Encode(e)
		}
	}
	{
		if s.Creator.Set {
			e.FieldStart("creator")
			s.Creator.Encode(e)
		}
	}
	{
		if s.LastModifyUser.Set {
			e.FieldStart("lastModifyUser")
			s.LastModifyUser.Encode(e)
		}
	}
}

var jsonFieldsNameOfProject = [7]string{
	0: "scriptId",
	1: "title",
	2: "parentId",
	3: "createTime",
	4: "updateTime",
	5: "creator",
	6: "lastModifyUser",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "scriptId":
			if err := func() error {
				s.ScriptId.Reset()
				if err := s.ScriptId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scriptId\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "parentId":
			if err := func() error {
				s.ParentId.Reset()
				if err := s.ParentId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentId\"")
			}
		case "createTime":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createTime\"")
			}
		case "updateTime":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateTime\"")
			}
		case "creator":
			if err := func() error {
				s.Creator.Reset()
				if err := s.Creator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"creator\"")
			}
		case "lastModifyUser":
			if err := func() error {
				s.LastModifyUser.Reset()
				if err := s.LastModifyUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModifyUser\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Project) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Project) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScriptFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScriptFile) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("createTime")
			s.CreateTime.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("updateTime")
			s.UpdateTime.Encode(e)
		}
	}
	{
		if s.LastModifyUser.Set {
			e.FieldStart("lastModifyUser")
			s.LastModifyUser.Encode(e)
		}
	}
	{
		if s.FunctionSet.Set {
			e.FieldStart("functionSet")
			s.FunctionSet.Encode(e)
		}
	}
}

var jsonFieldsNameOfScriptFile = [7]string{
	0: "name",
	1: "type",
	2: "source",
	3: "createTime",
	4: "updateTime",
	5: "lastModifyUser",
	6: "functionSet",
}

// Decode decodes ScriptFile from json.
func (s *ScriptFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScriptFile to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "createTime":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createTime\"")
			}
		case "updateTime":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateTime\"")
			}
		case "lastModifyUser":
			if err := func() error {
				s.LastModifyUser.Reset()
				if err := s.LastModifyUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModifyUser\"")
			}
		case "functionSet":
			if err := func() error {
				s.FunctionSet.Reset()
				if err := s.FunctionSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"functionSet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScriptFile")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScriptFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScriptFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ScriptFileFunctionSet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ScriptFileFunctionSet) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ScriptFileFunctionSet from json.
func (s *ScriptFileFunctionSet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScriptFileFunctionSet to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScriptFileFunctionSet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ScriptFileFunctionSet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScriptFileFunctionSet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScriptFileInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScriptFileInput) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
}

var jsonFieldsNameOfScriptFileInput = [3]string{
	0: "name",
	1: "type",
	2: "source",
}

// Decode decodes ScriptFileInput from json.
func (s *ScriptFileInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScriptFileInput to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScriptFileInput")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScriptFileInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScriptFileInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateContentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateContentRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateContentRequest = [1]string{
	0: "files",
}

// Decode decodes UpdateContentRequest from json.
func (s *UpdateContentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateContentRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "files":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Files = make([]ScriptFileInput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ScriptFileInput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateContentRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateContentRequest) {
					name = jsonFieldsNameOfUpdateContentRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateContentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateContentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDeploymentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDeploymentRequest) encodeFields(e *jx.Encoder) {
	{
		if s.DeploymentConfig.Set {
			e.FieldStart("deploymentConfig")
			s.DeploymentConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDeploymentRequest = [1]string{
	0: "deploymentConfig",
}

// Decode decodes UpdateDeploymentRequest from json.
func (s *UpdateDeploymentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDeploymentRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deploymentConfig":
			if err := func() error {
				s.DeploymentConfig.Reset()
				if err := s.DeploymentConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploymentConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDeploymentRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDeploymentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDeploymentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Version) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Version) encodeFields(e *jx.Encoder) {
	{
		if s.VersionNumber.Set {
			e.FieldStart("versionNumber")
			s.VersionNumber.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("createTime")
			s.CreateTime.Encode(e)
		}
	}
	{
		if s.ScriptId.Set {
			e.FieldStart("scriptId")
			s.ScriptId.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersion = [4]string{
	0: "versionNumber",
	1: "description",
	2: "createTime",
	3: "scriptId",
}

// Decode decodes Version from json.
func (s *Version) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Version to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versionNumber":
			if err := func() error {
				s.VersionNumber.Reset()
				if err := s.VersionNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versionNumber\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "createTime":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createTime\"")
			}
		case "scriptId":
			if err := func() error {
				s.ScriptId.Reset()
				if err := s.ScriptId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scriptId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Version")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Version) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Version) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionList) encodeFields(e *jx.Encoder) {
	{
		if s.Versions != nil {
			e.FieldStart("versions")
			e.ArrStart()
			for _, elem := range s.Versions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersionList = [2]string{
	0: "versions",
	1: "nextPageToken",
}

// Decode decodes VersionList from json.
func (s *VersionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "versions":
			if err := func() error {
				s.Versions = make([]Version, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Version
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
