// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *CreateTaskListReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTaskListReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("displayName")
		e.Str(s.DisplayName)
	}
}

var jsonFieldsNameOfCreateTaskListReq = [1]string{
	0: "displayName",
}

// Decode decodes CreateTaskListReq from json.
func (s *CreateTaskListReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTaskListReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTaskListReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTaskListReq) {
					name = jsonFieldsNameOfCreateTaskListReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTaskListReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTaskListReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTaskReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTaskReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Importance.Set {
			e.FieldStart("importance")
			s.Importance.Encode(e)
		}
	}
	{
		if s.DueDateTime.Set {
			e.FieldStart("dueDateTime")
			s.DueDateTime.Encode(e)
		}
	}
	{
		if s.ReminderDateTime.Set {
			e.FieldStart("reminderDateTime")
			s.ReminderDateTime.Encode(e)
		}
	}
	{
		if s.IsReminderOn.Set {
			e.FieldStart("isReminderOn")
			s.IsReminderOn.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTaskReq = [6]string{
	0: "title",
	1: "body",
	2: "importance",
	3: "dueDateTime",
	4: "reminderDateTime",
	5: "isReminderOn",
}

// Decode decodes CreateTaskReq from json.
func (s *CreateTaskReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTaskReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "importance":
			if err := func() error {
				s.Importance.Reset()
				if err := s.Importance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importance\"")
			}
		case "dueDateTime":
			if err := func() error {
				s.DueDateTime.Reset()
				if err := s.DueDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dueDateTime\"")
			}
		case "reminderDateTime":
			if err := func() error {
				s.ReminderDateTime.Reset()
				if err := s.ReminderDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reminderDateTime\"")
			}
		case "isReminderOn":
			if err := func() error {
				s.IsReminderOn.Reset()
				if err := s.IsReminderOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isReminderOn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTaskReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTaskReq) {
					name = jsonFieldsNameOfCreateTaskReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTaskReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTaskReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DateTimeTimeZone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DateTimeTimeZone) encodeFields(e *jx.Encoder) {
	{
		if s.DateTime.Set {
			e.FieldStart("dateTime")
			s.DateTime.Encode(e)
		}
	}
	{
		if s.TimeZone.Set {
			e.FieldStart("timeZone")
			s.TimeZone.Encode(e)
		}
	}
}

var jsonFieldsNameOfDateTimeTimeZone = [2]string{
	0: "dateTime",
	1: "timeZone",
}

// Decode decodes DateTimeTimeZone from json.
func (s *DateTimeTimeZone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DateTimeTimeZone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dateTime":
			if err := func() error {
				s.DateTime.Reset()
				if err := s.DateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTime\"")
			}
		case "timeZone":
			if err := func() error {
				s.TimeZone.Reset()
				if err := s.TimeZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeZone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DateTimeTimeZone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DateTimeTimeZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DateTimeTimeZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ItemBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ItemBody) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.ContentType.Set {
			e.FieldStart("contentType")
			s.ContentType.Encode(e)
		}
	}
}

var jsonFieldsNameOfItemBody = [2]string{
	0: "content",
	1: "contentType",
}

// Decode decodes ItemBody from json.
func (s *ItemBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ItemBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "contentType":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ItemBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ItemBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ItemBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DateTimeTimeZone as json.
func (o OptDateTimeTimeZone) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DateTimeTimeZone from json.
func (o *OptDateTimeTimeZone) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTimeTimeZone to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTimeTimeZone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTimeTimeZone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ItemBody as json.
func (o OptItemBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ItemBody from json.
func (o *OptItemBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptItemBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptItemBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptItemBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TodoTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TodoTask) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Importance.Set {
			e.FieldStart("importance")
			s.Importance.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.IsReminderOn.Set {
			e.FieldStart("isReminderOn")
			s.IsReminderOn.Encode(e)
		}
	}
	{
		if s.DueDateTime.Set {
			e.FieldStart("dueDateTime")
			s.DueDateTime.Encode(e)
		}
	}
	{
		if s.ReminderDateTime.Set {
			e.FieldStart("reminderDateTime")
			s.ReminderDateTime.Encode(e)
		}
	}
	{
		if s.CompletedDateTime.Set {
			e.FieldStart("completedDateTime")
			s.CompletedDateTime.Encode(e)
		}
	}
	{
		if s.CreatedDateTime.Set {
			e.FieldStart("createdDateTime")
			s.CreatedDateTime.Encode(e)
		}
	}
	{
		if s.LastModifiedDateTime.Set {
			e.FieldStart("lastModifiedDateTime")
			s.LastModifiedDateTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfTodoTask = [11]string{
	0:  "id",
	1:  "title",
	2:  "body",
	3:  "importance",
	4:  "status",
	5:  "isReminderOn",
	6:  "dueDateTime",
	7:  "reminderDateTime",
	8:  "completedDateTime",
	9:  "createdDateTime",
	10: "lastModifiedDateTime",
}

// Decode decodes TodoTask from json.
func (s *TodoTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TodoTask to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "importance":
			if err := func() error {
				s.Importance.Reset()
				if err := s.Importance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importance\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "isReminderOn":
			if err := func() error {
				s.IsReminderOn.Reset()
				if err := s.IsReminderOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isReminderOn\"")
			}
		case "dueDateTime":
			if err := func() error {
				s.DueDateTime.Reset()
				if err := s.DueDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dueDateTime\"")
			}
		case "reminderDateTime":
			if err := func() error {
				s.ReminderDateTime.Reset()
				if err := s.ReminderDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reminderDateTime\"")
			}
		case "completedDateTime":
			if err := func() error {
				s.CompletedDateTime.Reset()
				if err := s.CompletedDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedDateTime\"")
			}
		case "createdDateTime":
			if err := func() error {
				s.CreatedDateTime.Reset()
				if err := s.CreatedDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdDateTime\"")
			}
		case "lastModifiedDateTime":
			if err := func() error {
				s.LastModifiedDateTime.Reset()
				if err := s.LastModifiedDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastModifiedDateTime\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TodoTask")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TodoTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TodoTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TodoTaskCollectionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TodoTaskCollectionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Value != nil {
			e.FieldStart("value")
			e.ArrStart()
			for _, elem := range s.Value {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTodoTaskCollectionResponse = [1]string{
	0: "value",
}

// Decode decodes TodoTaskCollectionResponse from json.
func (s *TodoTaskCollectionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TodoTaskCollectionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value = make([]TodoTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TodoTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Value = append(s.Value, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TodoTaskCollectionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TodoTaskCollectionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TodoTaskCollectionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TodoTaskList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TodoTaskList) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.IsOwner.Set {
			e.FieldStart("isOwner")
			s.IsOwner.Encode(e)
		}
	}
	{
		if s.IsShared.Set {
			e.FieldStart("isShared")
			s.IsShared.Encode(e)
		}
	}
	{
		if s.WellknownListName.Set {
			e.FieldStart("wellknownListName")
			s.WellknownListName.Encode(e)
		}
	}
}

var jsonFieldsNameOfTodoTaskList = [5]string{
	0: "id",
	1: "displayName",
	2: "isOwner",
	3: "isShared",
	4: "wellknownListName",
}

// Decode decodes TodoTaskList from json.
func (s *TodoTaskList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TodoTaskList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "isOwner":
			if err := func() error {
				s.IsOwner.Reset()
				if err := s.IsOwner.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOwner\"")
			}
		case "isShared":
			if err := func() error {
				s.IsShared.Reset()
				if err := s.IsShared.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShared\"")
			}
		case "wellknownListName":
			if err := func() error {
				s.WellknownListName.Reset()
				if err := s.WellknownListName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wellknownListName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TodoTaskList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TodoTaskList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TodoTaskList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TodoTaskListCollectionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TodoTaskListCollectionResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Value != nil {
			e.FieldStart("value")
			e.ArrStart()
			for _, elem := range s.Value {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTodoTaskListCollectionResponse = [1]string{
	0: "value",
}

// Decode decodes TodoTaskListCollectionResponse from json.
func (s *TodoTaskListCollectionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TodoTaskListCollectionResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value = make([]TodoTaskList, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TodoTaskList
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Value = append(s.Value, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TodoTaskListCollectionResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TodoTaskListCollectionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TodoTaskListCollectionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTaskListReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTaskListReq) encodeFields(e *jx.Encoder) {
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTaskListReq = [1]string{
	0: "displayName",
}

// Decode decodes UpdateTaskListReq from json.
func (s *UpdateTaskListReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTaskListReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTaskListReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTaskListReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTaskListReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTaskReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTaskReq) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Importance.Set {
			e.FieldStart("importance")
			s.Importance.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.DueDateTime.Set {
			e.FieldStart("dueDateTime")
			s.DueDateTime.Encode(e)
		}
	}
	{
		if s.ReminderDateTime.Set {
			e.FieldStart("reminderDateTime")
			s.ReminderDateTime.Encode(e)
		}
	}
	{
		if s.IsReminderOn.Set {
			e.FieldStart("isReminderOn")
			s.IsReminderOn.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTaskReq = [7]string{
	0: "title",
	1: "body",
	2: "importance",
	3: "status",
	4: "dueDateTime",
	5: "reminderDateTime",
	6: "isReminderOn",
}

// Decode decodes UpdateTaskReq from json.
func (s *UpdateTaskReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTaskReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "importance":
			if err := func() error {
				s.Importance.Reset()
				if err := s.Importance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importance\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "dueDateTime":
			if err := func() error {
				s.DueDateTime.Reset()
				if err := s.DueDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dueDateTime\"")
			}
		case "reminderDateTime":
			if err := func() error {
				s.ReminderDateTime.Reset()
				if err := s.ReminderDateTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reminderDateTime\"")
			}
		case "isReminderOn":
			if err := func() error {
				s.IsReminderOn.Reset()
				if err := s.IsReminderOn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isReminderOn\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTaskReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTaskReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTaskReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
