// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
)

// Encode implements json.Marshaler.
func (s *About) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *About) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.StorageQuota.Set {
			e.FieldStart("storageQuota")
			s.StorageQuota.Encode(e)
		}
	}
}

var jsonFieldsNameOfAbout = [2]string{
	0: "user",
	1: "storageQuota",
}

// Decode decodes About from json.
func (s *About) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode About to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "storageQuota":
			if err := func() error {
				s.StorageQuota.Reset()
				if err := s.StorageQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageQuota\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode About")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *About) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *About) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AboutStorageQuota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AboutStorageQuota) encodeFields(e *jx.Encoder) {
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.UsageInDrive.Set {
			e.FieldStart("usageInDrive")
			s.UsageInDrive.Encode(e)
		}
	}
	{
		if s.UsageInDriveTrash.Set {
			e.FieldStart("usageInDriveTrash")
			s.UsageInDriveTrash.Encode(e)
		}
	}
}

var jsonFieldsNameOfAboutStorageQuota = [4]string{
	0: "limit",
	1: "usage",
	2: "usageInDrive",
	3: "usageInDriveTrash",
}

// Decode decodes AboutStorageQuota from json.
func (s *AboutStorageQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AboutStorageQuota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "usageInDrive":
			if err := func() error {
				s.UsageInDrive.Reset()
				if err := s.UsageInDrive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageInDrive\"")
			}
		case "usageInDriveTrash":
			if err := func() error {
				s.UsageInDriveTrash.Reset()
				if err := s.UsageInDriveTrash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usageInDriveTrash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AboutStorageQuota")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AboutStorageQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AboutStorageQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AboutUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AboutUser) encodeFields(e *jx.Encoder) {
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.EmailAddress.Set {
			e.FieldStart("emailAddress")
			s.EmailAddress.Encode(e)
		}
	}
	{
		if s.PhotoLink.Set {
			e.FieldStart("photoLink")
			s.PhotoLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfAboutUser = [3]string{
	0: "displayName",
	1: "emailAddress",
	2: "photoLink",
}

// Decode decodes AboutUser from json.
func (s *AboutUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AboutUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "emailAddress":
			if err := func() error {
				s.EmailAddress.Reset()
				if err := s.EmailAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailAddress\"")
			}
		case "photoLink":
			if err := func() error {
				s.PhotoLink.Reset()
				if err := s.PhotoLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AboutUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AboutUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AboutUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Comment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Comment) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.CreatedTime.Set {
			e.FieldStart("createdTime")
			s.CreatedTime.Encode(e)
		}
	}
	{
		if s.ModifiedTime.Set {
			e.FieldStart("modifiedTime")
			s.ModifiedTime.Encode(e)
		}
	}
	{
		if s.Resolved.Set {
			e.FieldStart("resolved")
			s.Resolved.Encode(e)
		}
	}
	{
		if s.Replies.Set {
			e.FieldStart("replies")
			s.Replies.Encode(e)
		}
	}
}

var jsonFieldsNameOfComment = [7]string{
	0: "id",
	1: "content",
	2: "author",
	3: "createdTime",
	4: "modifiedTime",
	5: "resolved",
	6: "replies",
}

// Decode decodes Comment from json.
func (s *Comment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Comment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "createdTime":
			if err := func() error {
				s.CreatedTime.Reset()
				if err := s.CreatedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdTime\"")
			}
		case "modifiedTime":
			if err := func() error {
				s.ModifiedTime.Reset()
				if err := s.ModifiedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiedTime\"")
			}
		case "resolved":
			if err := func() error {
				s.Resolved.Reset()
				if err := s.Resolved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resolved\"")
			}
		case "replies":
			if err := func() error {
				s.Replies.Reset()
				if err := s.Replies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replies\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Comment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Comment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Comment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentAuthor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentAuthor) encodeFields(e *jx.Encoder) {
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.EmailAddress.Set {
			e.FieldStart("emailAddress")
			s.EmailAddress.Encode(e)
		}
	}
	{
		if s.PhotoLink.Set {
			e.FieldStart("photoLink")
			s.PhotoLink.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentAuthor = [3]string{
	0: "displayName",
	1: "emailAddress",
	2: "photoLink",
}

// Decode decodes CommentAuthor from json.
func (s *CommentAuthor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentAuthor to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "emailAddress":
			if err := func() error {
				s.EmailAddress.Reset()
				if err := s.EmailAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailAddress\"")
			}
		case "photoLink":
			if err := func() error {
				s.PhotoLink.Reset()
				if err := s.PhotoLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentAuthor")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentList) encodeFields(e *jx.Encoder) {
	{
		if s.Comments != nil {
			e.FieldStart("comments")
			e.ArrStart()
			for _, elem := range s.Comments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentList = [2]string{
	0: "comments",
	1: "nextPageToken",
}

// Decode decodes CommentList from json.
func (s *CommentList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "comments":
			if err := func() error {
				s.Comments = make([]Comment, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Comment
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Comments = append(s.Comments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"comments\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.QuotedFileContent.Set {
			e.FieldStart("quotedFileContent")
			s.QuotedFileContent.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentRequest = [2]string{
	0: "content",
	1: "quotedFileContent",
}

// Decode decodes CommentRequest from json.
func (s *CommentRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "quotedFileContent":
			if err := func() error {
				s.QuotedFileContent.Reset()
				if err := s.QuotedFileContent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotedFileContent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommentRequestQuotedFileContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommentRequestQuotedFileContent) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommentRequestQuotedFileContent = [1]string{
	0: "value",
}

// Decode decodes CommentRequestQuotedFileContent from json.
func (s *CommentRequestQuotedFileContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommentRequestQuotedFileContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommentRequestQuotedFileContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommentRequestQuotedFileContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommentRequestQuotedFileContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Parents.Set {
			e.FieldStart("parents")
			s.Parents.Encode(e)
		}
	}
}

var jsonFieldsNameOfCopyRequest = [2]string{
	0: "name",
	1: "parents",
}

// Decode decodes CopyRequest from json.
func (s *CopyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "parents":
			if err := func() error {
				s.Parents.Reset()
				if err := s.Parents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *File) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *File) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mimeType")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.CreatedTime.Set {
			e.FieldStart("createdTime")
			s.CreatedTime.Encode(e)
		}
	}
	{
		if s.ModifiedTime.Set {
			e.FieldStart("modifiedTime")
			s.ModifiedTime.Encode(e)
		}
	}
	{
		if s.Parents.Set {
			e.FieldStart("parents")
			s.Parents.Encode(e)
		}
	}
	{
		if s.WebViewLink.Set {
			e.FieldStart("webViewLink")
			s.WebViewLink.Encode(e)
		}
	}
	{
		if s.IconLink.Set {
			e.FieldStart("iconLink")
			s.IconLink.Encode(e)
		}
	}
	{
		if s.Trashed.Set {
			e.FieldStart("trashed")
			s.Trashed.Encode(e)
		}
	}
}

var jsonFieldsNameOfFile = [10]string{
	0: "id",
	1: "name",
	2: "mimeType",
	3: "size",
	4: "createdTime",
	5: "modifiedTime",
	6: "parents",
	7: "webViewLink",
	8: "iconLink",
	9: "trashed",
}

// Decode decodes File from json.
func (s *File) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode File to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "mimeType":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mimeType\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "createdTime":
			if err := func() error {
				s.CreatedTime.Reset()
				if err := s.CreatedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdTime\"")
			}
		case "modifiedTime":
			if err := func() error {
				s.ModifiedTime.Reset()
				if err := s.ModifiedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiedTime\"")
			}
		case "parents":
			if err := func() error {
				s.Parents.Reset()
				if err := s.Parents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "webViewLink":
			if err := func() error {
				s.WebViewLink.Reset()
				if err := s.WebViewLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webViewLink\"")
			}
		case "iconLink":
			if err := func() error {
				s.IconLink.Reset()
				if err := s.IconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iconLink\"")
			}
		case "trashed":
			if err := func() error {
				s.Trashed.Reset()
				if err := s.Trashed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode File")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *File) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *File) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileList) encodeFields(e *jx.Encoder) {
	{
		if s.Files != nil {
			e.FieldStart("files")
			e.ArrStart()
			for _, elem := range s.Files {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileList = [2]string{
	0: "files",
	1: "nextPageToken",
}

// Decode decodes FileList from json.
func (s *FileList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "files":
			if err := func() error {
				s.Files = make([]File, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem File
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileMetadata) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mimeType")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.Parents.Set {
			e.FieldStart("parents")
			s.Parents.Encode(e)
		}
	}
	{
		if s.Trashed.Set {
			e.FieldStart("trashed")
			s.Trashed.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileMetadata = [4]string{
	0: "name",
	1: "mimeType",
	2: "parents",
	3: "trashed",
}

// Decode decodes FileMetadata from json.
func (s *FileMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "mimeType":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mimeType\"")
			}
		case "parents":
			if err := func() error {
				s.Parents.Reset()
				if err := s.Parents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parents\"")
			}
		case "trashed":
			if err := func() error {
				s.Trashed.Reset()
				if err := s.Trashed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trashed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommentAuthor as json.
func (o OptCommentAuthor) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CommentAuthor from json.
func (o *OptCommentAuthor) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCommentAuthor to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCommentAuthor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCommentAuthor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommentRequestQuotedFileContent as json.
func (o OptCommentRequestQuotedFileContent) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CommentRequestQuotedFileContent from json.
func (o *OptCommentRequestQuotedFileContent) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCommentRequestQuotedFileContent to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCommentRequestQuotedFileContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCommentRequestQuotedFileContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AboutStorageQuota as json.
func (o OptNilAboutStorageQuota) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AboutStorageQuota from json.
func (o *OptNilAboutStorageQuota) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAboutStorageQuota to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AboutStorageQuota
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAboutStorageQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAboutStorageQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AboutUser as json.
func (o OptNilAboutUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AboutUser from json.
func (o *OptNilAboutUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAboutUser to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AboutUser
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAboutUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAboutUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []Reply as json.
func (o OptNilReplyArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []Reply from json.
func (o *OptNilReplyArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilReplyArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []Reply
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]Reply, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem Reply
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilReplyArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilReplyArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Permission) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Permission) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.EmailAddress.Set {
			e.FieldStart("emailAddress")
			s.EmailAddress.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
}

var jsonFieldsNameOfPermission = [6]string{
	0: "id",
	1: "type",
	2: "role",
	3: "emailAddress",
	4: "domain",
	5: "displayName",
}

// Decode decodes Permission from json.
func (s *Permission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Permission to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "emailAddress":
			if err := func() error {
				s.EmailAddress.Reset()
				if err := s.EmailAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailAddress\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Permission")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Permission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Permission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PermissionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PermissionList) encodeFields(e *jx.Encoder) {
	{
		if s.Permissions != nil {
			e.FieldStart("permissions")
			e.ArrStart()
			for _, elem := range s.Permissions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPermissionList = [1]string{
	0: "permissions",
}

// Decode decodes PermissionList from json.
func (s *PermissionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "permissions":
			if err := func() error {
				s.Permissions = make([]Permission, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Permission
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Permissions = append(s.Permissions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PermissionList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PermissionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PermissionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PermissionRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		if s.EmailAddress.Set {
			e.FieldStart("emailAddress")
			s.EmailAddress.Encode(e)
		}
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
}

var jsonFieldsNameOfPermissionRequest = [4]string{
	0: "type",
	1: "role",
	2: "emailAddress",
	3: "domain",
}

// Decode decodes PermissionRequest from json.
func (s *PermissionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PermissionRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "emailAddress":
			if err := func() error {
				s.EmailAddress.Reset()
				if err := s.EmailAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"emailAddress\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PermissionRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PermissionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PermissionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Reply) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Reply) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.CreatedTime.Set {
			e.FieldStart("createdTime")
			s.CreatedTime.Encode(e)
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
}

var jsonFieldsNameOfReply = [5]string{
	0: "id",
	1: "content",
	2: "author",
	3: "createdTime",
	4: "action",
}

// Decode decodes Reply from json.
func (s *Reply) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Reply to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "createdTime":
			if err := func() error {
				s.CreatedTime.Reset()
				if err := s.CreatedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdTime\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Reply")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Reply) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Reply) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReplyRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReplyRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
}

var jsonFieldsNameOfReplyRequest = [2]string{
	0: "content",
	1: "action",
}

// Decode decodes ReplyRequest from json.
func (s *ReplyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReplyRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReplyRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReplyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReplyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Revision) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Revision) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.MimeType.Set {
			e.FieldStart("mimeType")
			s.MimeType.Encode(e)
		}
	}
	{
		if s.ModifiedTime.Set {
			e.FieldStart("modifiedTime")
			s.ModifiedTime.Encode(e)
		}
	}
	{
		if s.KeepForever.Set {
			e.FieldStart("keepForever")
			s.KeepForever.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfRevision = [5]string{
	0: "id",
	1: "mimeType",
	2: "modifiedTime",
	3: "keepForever",
	4: "size",
}

// Decode decodes Revision from json.
func (s *Revision) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Revision to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "mimeType":
			if err := func() error {
				s.MimeType.Reset()
				if err := s.MimeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mimeType\"")
			}
		case "modifiedTime":
			if err := func() error {
				s.ModifiedTime.Reset()
				if err := s.ModifiedTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifiedTime\"")
			}
		case "keepForever":
			if err := func() error {
				s.KeepForever.Reset()
				if err := s.KeepForever.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keepForever\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Revision")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Revision) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Revision) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevisionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevisionList) encodeFields(e *jx.Encoder) {
	{
		if s.Revisions != nil {
			e.FieldStart("revisions")
			e.ArrStart()
			for _, elem := range s.Revisions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfRevisionList = [2]string{
	0: "revisions",
	1: "nextPageToken",
}

// Decode decodes RevisionList from json.
func (s *RevisionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevisionList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "revisions":
			if err := func() error {
				s.Revisions = make([]Revision, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Revision
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Revisions = append(s.Revisions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisions\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevisionList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevisionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevisionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedDrive) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedDrive) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfSharedDrive = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes SharedDrive from json.
func (s *SharedDrive) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedDrive to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedDrive")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedDrive) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedDrive) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SharedDriveList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SharedDriveList) encodeFields(e *jx.Encoder) {
	{
		if s.Drives != nil {
			e.FieldStart("drives")
			e.ArrStart()
			for _, elem := range s.Drives {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfSharedDriveList = [2]string{
	0: "drives",
	1: "nextPageToken",
}

// Decode decodes SharedDriveList from json.
func (s *SharedDriveList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SharedDriveList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drives":
			if err := func() error {
				s.Drives = make([]SharedDrive, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SharedDrive
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Drives = append(s.Drives, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drives\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SharedDriveList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SharedDriveList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SharedDriveList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
