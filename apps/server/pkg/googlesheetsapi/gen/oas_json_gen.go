// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AppendValuesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AppendValuesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.TableRange.Set {
			e.FieldStart("tableRange")
			s.TableRange.Encode(e)
		}
	}
	{
		if s.Updates.Set {
			e.FieldStart("updates")
			s.Updates.Encode(e)
		}
	}
}

var jsonFieldsNameOfAppendValuesResponse = [3]string{
	0: "spreadsheetId",
	1: "tableRange",
	2: "updates",
}

// Decode decodes AppendValuesResponse from json.
func (s *AppendValuesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppendValuesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "tableRange":
			if err := func() error {
				s.TableRange.Reset()
				if err := s.TableRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tableRange\"")
			}
		case "updates":
			if err := func() error {
				s.Updates.Reset()
				if err := s.Updates.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppendValuesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AppendValuesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppendValuesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s AppendValuesResponseUpdates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s AppendValuesResponseUpdates) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes AppendValuesResponseUpdates from json.
func (s *AppendValuesResponseUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AppendValuesResponseUpdates to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AppendValuesResponseUpdates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AppendValuesResponseUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AppendValuesResponseUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchGetValuesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchGetValuesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.ValueRanges.Set {
			e.FieldStart("valueRanges")
			s.ValueRanges.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchGetValuesResponse = [2]string{
	0: "spreadsheetId",
	1: "valueRanges",
}

// Decode decodes BatchGetValuesResponse from json.
func (s *BatchGetValuesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchGetValuesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "valueRanges":
			if err := func() error {
				s.ValueRanges.Reset()
				if err := s.ValueRanges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueRanges\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchGetValuesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchGetValuesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchGetValuesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("requests")
		e.ArrStart()
		for _, elem := range s.Requests {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBatchUpdateRequest = [1]string{
	0: "requests",
}

// Decode decodes BatchUpdateRequest from json.
func (s *BatchUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requests":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Requests = make([]BatchUpdateRequestRequestsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BatchUpdateRequestRequestsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Requests = append(s.Requests, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requests\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBatchUpdateRequest) {
					name = jsonFieldsNameOfBatchUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BatchUpdateRequestRequestsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BatchUpdateRequestRequestsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes BatchUpdateRequestRequestsItem from json.
func (s *BatchUpdateRequestRequestsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateRequestRequestsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateRequestRequestsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchUpdateRequestRequestsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateRequestRequestsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.Replies.Set {
			e.FieldStart("replies")
			s.Replies.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateResponse = [2]string{
	0: "spreadsheetId",
	1: "replies",
}

// Decode decodes BatchUpdateResponse from json.
func (s *BatchUpdateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "replies":
			if err := func() error {
				s.Replies.Reset()
				if err := s.Replies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replies\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BatchUpdateResponseRepliesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BatchUpdateResponseRepliesItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes BatchUpdateResponseRepliesItem from json.
func (s *BatchUpdateResponseRepliesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateResponseRepliesItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateResponseRepliesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BatchUpdateResponseRepliesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateResponseRepliesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateValuesRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateValuesRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ValueInputOption.Set {
			e.FieldStart("valueInputOption")
			s.ValueInputOption.Encode(e)
		}
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfBatchUpdateValuesRequest = [2]string{
	0: "valueInputOption",
	1: "data",
}

// Decode decodes BatchUpdateValuesRequest from json.
func (s *BatchUpdateValuesRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateValuesRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valueInputOption":
			if err := func() error {
				s.ValueInputOption.Reset()
				if err := s.ValueInputOption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueInputOption\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]ValueRange, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ValueRange
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateValuesRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateValuesRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateValuesRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BatchUpdateValuesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BatchUpdateValuesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.TotalUpdatedRows.Set {
			e.FieldStart("totalUpdatedRows")
			s.TotalUpdatedRows.Encode(e)
		}
	}
	{
		if s.TotalUpdatedColumns.Set {
			e.FieldStart("totalUpdatedColumns")
			s.TotalUpdatedColumns.Encode(e)
		}
	}
	{
		if s.TotalUpdatedCells.Set {
			e.FieldStart("totalUpdatedCells")
			s.TotalUpdatedCells.Encode(e)
		}
	}
	{
		if s.TotalUpdatedSheets.Set {
			e.FieldStart("totalUpdatedSheets")
			s.TotalUpdatedSheets.Encode(e)
		}
	}
}

var jsonFieldsNameOfBatchUpdateValuesResponse = [5]string{
	0: "spreadsheetId",
	1: "totalUpdatedRows",
	2: "totalUpdatedColumns",
	3: "totalUpdatedCells",
	4: "totalUpdatedSheets",
}

// Decode decodes BatchUpdateValuesResponse from json.
func (s *BatchUpdateValuesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BatchUpdateValuesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "totalUpdatedRows":
			if err := func() error {
				s.TotalUpdatedRows.Reset()
				if err := s.TotalUpdatedRows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpdatedRows\"")
			}
		case "totalUpdatedColumns":
			if err := func() error {
				s.TotalUpdatedColumns.Reset()
				if err := s.TotalUpdatedColumns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpdatedColumns\"")
			}
		case "totalUpdatedCells":
			if err := func() error {
				s.TotalUpdatedCells.Reset()
				if err := s.TotalUpdatedCells.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpdatedCells\"")
			}
		case "totalUpdatedSheets":
			if err := func() error {
				s.TotalUpdatedSheets.Reset()
				if err := s.TotalUpdatedSheets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpdatedSheets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BatchUpdateValuesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BatchUpdateValuesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BatchUpdateValuesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClearValuesReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClearValuesReq) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfClearValuesReq = [0]string{}

// Decode decodes ClearValuesReq from json.
func (s *ClearValuesReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClearValuesReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ClearValuesReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClearValuesReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClearValuesReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClearValuesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClearValuesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.ClearedRange.Set {
			e.FieldStart("clearedRange")
			s.ClearedRange.Encode(e)
		}
	}
}

var jsonFieldsNameOfClearValuesResponse = [2]string{
	0: "spreadsheetId",
	1: "clearedRange",
}

// Decode decodes ClearValuesResponse from json.
func (s *ClearValuesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClearValuesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "clearedRange":
			if err := func() error {
				s.ClearedRange.Reset()
				if err := s.ClearedRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearedRange\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClearValuesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClearValuesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClearValuesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopySheetToRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopySheetToRequest) encodeFields(e *jx.Encoder) {
	{
		if s.DestinationSpreadsheetId.Set {
			e.FieldStart("destinationSpreadsheetId")
			s.DestinationSpreadsheetId.Encode(e)
		}
	}
}

var jsonFieldsNameOfCopySheetToRequest = [1]string{
	0: "destinationSpreadsheetId",
}

// Decode decodes CopySheetToRequest from json.
func (s *CopySheetToRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopySheetToRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "destinationSpreadsheetId":
			if err := func() error {
				s.DestinationSpreadsheetId.Reset()
				if err := s.DestinationSpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destinationSpreadsheetId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopySheetToRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopySheetToRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopySheetToRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSpreadsheetRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSpreadsheetRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.Sheets.Set {
			e.FieldStart("sheets")
			s.Sheets.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSpreadsheetRequest = [2]string{
	0: "properties",
	1: "sheets",
}

// Decode decodes CreateSpreadsheetRequest from json.
func (s *CreateSpreadsheetRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpreadsheetRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "sheets":
			if err := func() error {
				s.Sheets.Reset()
				if err := s.Sheets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sheets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpreadsheetRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSpreadsheetRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpreadsheetRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateSpreadsheetRequestProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateSpreadsheetRequestProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CreateSpreadsheetRequestProperties from json.
func (s *CreateSpreadsheetRequestProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpreadsheetRequestProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpreadsheetRequestProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSpreadsheetRequestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpreadsheetRequestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateSpreadsheetRequestSheetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateSpreadsheetRequestSheetsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes CreateSpreadsheetRequestSheetsItem from json.
func (s *CreateSpreadsheetRequestSheetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSpreadsheetRequestSheetsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSpreadsheetRequestSheetsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSpreadsheetRequestSheetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSpreadsheetRequestSheetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes [][]jx.Raw as json.
func (o OptNilAnyArrayArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.ArrStart()
		for _, elem := range elem {
			if len(elem) != 0 {
				e.Raw(elem)
			}
		}
		e.ArrEnd()
	}
	e.ArrEnd()
}

// Decode decodes [][]jx.Raw from json.
func (o *OptNilAnyArrayArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAnyArrayArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v [][]jx.Raw
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([][]jx.Raw, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem []jx.Raw
		elem = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elemElem jx.Raw
			v, err := d.RawAppend(nil)
			elemElem = jx.Raw(v)
			if err != nil {
				return err
			}
			elem = append(elem, elemElem)
			return nil
		}); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAnyArrayArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAnyArrayArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AppendValuesResponseUpdates as json.
func (o OptNilAppendValuesResponseUpdates) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AppendValuesResponseUpdates from json.
func (o *OptNilAppendValuesResponseUpdates) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilAppendValuesResponseUpdates to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v AppendValuesResponseUpdates
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(AppendValuesResponseUpdates)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilAppendValuesResponseUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilAppendValuesResponseUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []BatchUpdateResponseRepliesItem as json.
func (o OptNilBatchUpdateResponseRepliesItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []BatchUpdateResponseRepliesItem from json.
func (o *OptNilBatchUpdateResponseRepliesItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBatchUpdateResponseRepliesItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []BatchUpdateResponseRepliesItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]BatchUpdateResponseRepliesItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem BatchUpdateResponseRepliesItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBatchUpdateResponseRepliesItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBatchUpdateResponseRepliesItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSpreadsheetRequestProperties as json.
func (o OptNilCreateSpreadsheetRequestProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateSpreadsheetRequestProperties from json.
func (o *OptNilCreateSpreadsheetRequestProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateSpreadsheetRequestProperties to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateSpreadsheetRequestProperties
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(CreateSpreadsheetRequestProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateSpreadsheetRequestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateSpreadsheetRequestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []CreateSpreadsheetRequestSheetsItem as json.
func (o OptNilCreateSpreadsheetRequestSheetsItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []CreateSpreadsheetRequestSheetsItem from json.
func (o *OptNilCreateSpreadsheetRequestSheetsItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateSpreadsheetRequestSheetsItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []CreateSpreadsheetRequestSheetsItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]CreateSpreadsheetRequestSheetsItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem CreateSpreadsheetRequestSheetsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateSpreadsheetRequestSheetsItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateSpreadsheetRequestSheetsItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpreadsheetProperties as json.
func (o OptNilSpreadsheetProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpreadsheetProperties from json.
func (o *OptNilSpreadsheetProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpreadsheetProperties to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v SpreadsheetProperties
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(SpreadsheetProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpreadsheetProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpreadsheetProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []SpreadsheetSheetsItem as json.
func (o OptNilSpreadsheetSheetsItemArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []SpreadsheetSheetsItem from json.
func (o *OptNilSpreadsheetSheetsItemArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilSpreadsheetSheetsItemArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []SpreadsheetSheetsItem
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]SpreadsheetSheetsItem, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem SpreadsheetSheetsItem
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilSpreadsheetSheetsItemArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilSpreadsheetSheetsItemArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []ValueRange as json.
func (o OptNilValueRangeArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes []ValueRange from json.
func (o *OptNilValueRangeArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilValueRangeArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []ValueRange
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]ValueRange, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem ValueRange
		if err := elem.Decode(d); err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilValueRangeArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilValueRangeArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SheetProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SheetProperties) encodeFields(e *jx.Encoder) {
	{
		if s.SheetId.Set {
			e.FieldStart("sheetId")
			s.SheetId.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Index.Set {
			e.FieldStart("index")
			s.Index.Encode(e)
		}
	}
	{
		if s.SheetType.Set {
			e.FieldStart("sheetType")
			s.SheetType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSheetProperties = [4]string{
	0: "sheetId",
	1: "title",
	2: "index",
	3: "sheetType",
}

// Decode decodes SheetProperties from json.
func (s *SheetProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SheetProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sheetId":
			if err := func() error {
				s.SheetId.Reset()
				if err := s.SheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sheetId\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "sheetType":
			if err := func() error {
				s.SheetType.Reset()
				if err := s.SheetType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sheetType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SheetProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SheetProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SheetProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Spreadsheet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Spreadsheet) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.Sheets.Set {
			e.FieldStart("sheets")
			s.Sheets.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpreadsheet = [3]string{
	0: "spreadsheetId",
	1: "properties",
	2: "sheets",
}

// Decode decodes Spreadsheet from json.
func (s *Spreadsheet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Spreadsheet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "sheets":
			if err := func() error {
				s.Sheets.Reset()
				if err := s.Sheets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sheets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Spreadsheet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Spreadsheet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Spreadsheet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpreadsheetProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpreadsheetProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpreadsheetProperties from json.
func (s *SpreadsheetProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpreadsheetProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpreadsheetProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpreadsheetProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpreadsheetProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpreadsheetSheetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpreadsheetSheetsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpreadsheetSheetsItem from json.
func (s *SpreadsheetSheetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpreadsheetSheetsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpreadsheetSheetsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpreadsheetSheetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpreadsheetSheetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateValuesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateValuesResponse) encodeFields(e *jx.Encoder) {
	{
		if s.SpreadsheetId.Set {
			e.FieldStart("spreadsheetId")
			s.SpreadsheetId.Encode(e)
		}
	}
	{
		if s.UpdatedRange.Set {
			e.FieldStart("updatedRange")
			s.UpdatedRange.Encode(e)
		}
	}
	{
		if s.UpdatedRows.Set {
			e.FieldStart("updatedRows")
			s.UpdatedRows.Encode(e)
		}
	}
	{
		if s.UpdatedColumns.Set {
			e.FieldStart("updatedColumns")
			s.UpdatedColumns.Encode(e)
		}
	}
	{
		if s.UpdatedCells.Set {
			e.FieldStart("updatedCells")
			s.UpdatedCells.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateValuesResponse = [5]string{
	0: "spreadsheetId",
	1: "updatedRange",
	2: "updatedRows",
	3: "updatedColumns",
	4: "updatedCells",
}

// Decode decodes UpdateValuesResponse from json.
func (s *UpdateValuesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateValuesResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spreadsheetId":
			if err := func() error {
				s.SpreadsheetId.Reset()
				if err := s.SpreadsheetId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spreadsheetId\"")
			}
		case "updatedRange":
			if err := func() error {
				s.UpdatedRange.Reset()
				if err := s.UpdatedRange.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedRange\"")
			}
		case "updatedRows":
			if err := func() error {
				s.UpdatedRows.Reset()
				if err := s.UpdatedRows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedRows\"")
			}
		case "updatedColumns":
			if err := func() error {
				s.UpdatedColumns.Reset()
				if err := s.UpdatedColumns.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedColumns\"")
			}
		case "updatedCells":
			if err := func() error {
				s.UpdatedCells.Reset()
				if err := s.UpdatedCells.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedCells\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateValuesResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateValuesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateValuesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ValueRange) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ValueRange) encodeFields(e *jx.Encoder) {
	{
		if s.Range.Set {
			e.FieldStart("range")
			s.Range.Encode(e)
		}
	}
	{
		if s.MajorDimension.Set {
			e.FieldStart("majorDimension")
			s.MajorDimension.Encode(e)
		}
	}
	{
		if s.Values.Set {
			e.FieldStart("values")
			s.Values.Encode(e)
		}
	}
}

var jsonFieldsNameOfValueRange = [3]string{
	0: "range",
	1: "majorDimension",
	2: "values",
}

// Decode decodes ValueRange from json.
func (s *ValueRange) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ValueRange to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "range":
			if err := func() error {
				s.Range.Reset()
				if err := s.Range.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		case "majorDimension":
			if err := func() error {
				s.MajorDimension.Reset()
				if err := s.MajorDimension.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"majorDimension\"")
			}
		case "values":
			if err := func() error {
				s.Values.Reset()
				if err := s.Values.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ValueRange")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ValueRange) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ValueRange) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
